# 사용자 동작에 따른 ‘Segment’ Flow

# UX 원칙

- **사용자는 “세션”만 인지.** “세그먼트”라는 단어는 **UI에 노출 금지**.
- 내부적으로만 세그먼트로 쪼개 통계/집계를 정확히 함.

# 이벤트별 동작 요약

| 이벤트 | 세션 상태 변화 | 세그먼트(내부 동작) | 사용자용 문구 |
| --- | --- | --- | --- |
| **파트 변경** | `running → paused` | 현재 세그먼트 종료 | 배너: `세션이 일시정지되었습니다.` 버튼: `새 파트에서 시작하기` |
| **기존 파트 이어하기** | `paused → running` | 새 세그먼트 시작 | `이전 작업을 이어서 시작합니다.` |
| **새로운 파트에서 시작** | 새 Part 기준으로 **새 세션 생성** (`running`) | 새 세그먼트 시작 | `새 파트에서 기록을 시작합니다.` |
| **수동 일시정지** | `running → paused` | 현재 세그먼트 종료 | `일시정지되었습니다.` |
| **수동 재시작(이어하기)** | `paused → running` | 새 세그먼트 시작 | `기록을 다시 시작합니다.` |
| **자정 교차** | 상태 유지(`running`) | 자동 세그먼트 분리 | (표시 없음) |
| **[추후 개발] 메인카운터 모드 변경 (Row ↔ Free)** | 상태 유지(`running`) | 현재 세그먼트 종료 → 새 세그먼트 시작 | `모드가 변경되었습니다. 기록은 계속됩니다.` |

# 왜 이렇게?

세그먼트 구조는 세션을 인위적으로 쪼개지 않아도, **일시정지·재시작·자정 교차·모드 변경 등의 이벤트를 자동으로 기록 구간으로 구분**하기 위해 도입함.

이를 통해 사용자는 단순히 “시작·일시정지·이어하기”만 조작해도, 앱은 내부적으로 **정확한 작업 흐름과 시간을 세밀하게 추적**할 수 있음.

# 내부 저장(핵심 필드)

- `session(id, project_id, part_id_current, started_at, closed_at, note ...)`
- `session_segment(id, session_id, part_id, ~~mode(row|free)~~, started_at, ended_at, duration_sec, start_count, end_count, reason(mode_change|part_change|pause|midnight_split))`
    - Row 모드일 때만 `start_count/end_count` 저장.
    - Free 모드 세그먼트는 시간만 집계(히트맵에는 반영, 단/페이스 통계 제외). [추후 개발 예정]

# 추가 UX 디테일

- 파트 변경 시 배너 고정: `세션 일시정지됨 · [이 파트에서 새로 시작]`
- 모드 변경 시 추가 입력 없음(원터치). 설정에서 “모드 전환 시 확인 팝업” 토글 제공 가능. [추후 개발 예정]
- 프로젝트 상세 진입 시: “가장 최근에 작업하던 파트” 자동 포커스 + 세션 상태 표시(진행/일시정지).

# 통계 규칙 요약

- 히트맵: **세그먼트 duration**만 일자별 합산.
- 단/페이스: **Row 세그먼트**만 집계(Free 제외).
- 파트/모드/기간 필터는 모두 **세그먼트 기준**으로 계산.

이렇게 하면 사용자는 “세션이 끊기지 않고 자연스럽게 이어진다”만 느끼고, 우리는 내부적으로 정확한 통계를 확보할 수 있음.