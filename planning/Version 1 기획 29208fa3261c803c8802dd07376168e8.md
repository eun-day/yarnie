# Version 1 기획

담당자: 김도비
진행 상태: 진행 중
프로젝트: Yarnie 앱 개발 (https://www.notion.so/Yarnie-24208fa3261c801cbdc8e2b29717b7dd?pvs=21)
주차: 2025-W43
최종 편집 일시: 2025년 11월 3일 오후 4:14

### Label 개념을 Part로 확장 변경

- 가볍게 현재 작업 세션에 붙이는 라벨 정도로 생각했으나,
- 파트로 변경해 파트 단위로 작업을 진행하기 편한 방향으로 변경
- 기본적으로 파트 한 개가 생성되어 있음
- 프로젝트 상세 화면으로 들어오면 마지막으로 작업한 파트 데이터를 보여준다
- 파트 안에서는 카운터 기능이 메인이 된다.
- 파트 별로 메인 카운터 1개가 기본이며, 버디 카운터를 1개씩 추가할 수 있다.

## **Part**

> A Part represents a specific section or stage within your project —
it can follow the pattern’s structure or your own custom division (like body, sleeve, or collar).
> 
> 
> **파트는 프로젝트를 구성하는 특정 구간 또는 단계입니다.**
> 
> 도안에 따라 구분된 섹션일 수도 있고,
> 
> 사용자가 임의로 정한 구간(예: 몸통, 소매, 목 부분 등)일 수도 있습니다.
> 
> ---
> 
> 🔹 **기본 개념**
> 
> | 항목 | 설명 |
> | --- | --- |
> | **역할** | 프로젝트 내에서 하나의 독립된 작업 구간을 나타냅니다. |
> | **구성 요소** | 각 파트는 기본적으로 **Main Counter** 1개와, 필요한 경우 여러 개의 **Buddy Counter**를 가질 수 있습니다. |
> | **이름 지정** | 사용자가 자유롭게 파트 이름을 정할 수 있습니다. (예: Body, Sleeve, Neck) |
> | **정렬 기준** | 기본적으로 **만든 순서대로** 표시되지만, 사용자가 **순서를 직접 변경**할 수도 있습니다. |
> | **사용 목적** | 도안 단계를 따라가거나, 실제 작업 부위를 구분해 관리하기 위한 단위입니다. |
> 
> ---
> 
> 🔹 **예시**
> 
> | 예시 | 설명 |
> | --- | --- |
> | **Pattern-based Part** | 도안에 명시된 단계(예: Part 1: Ribbing, Part 2: Main body...)에 맞춰 생성 |
> | **Custom Part** | 사용자가 “몸통 / 오른팔 / 왼팔 / 목둘레”처럼 직접 나눈 구간 |
> | **단일 파트 프로젝트** | 작은 소품이나 단순 작업은 파트를 1개만 만들어도 충분 |
> 
> ---
> 
> 💬 **앱 설명 문구 예시**
> 
> > “Divide your project into Parts to track each section separately — like body, sleeves, or collar.”
> > 
> > 
> > “프로젝트를 파트로 나누면 각 구간의 진행을 따로 관리할 수 있습니다.
> > 
> > 예를 들어 몸통, 소매, 목 부분 등을 각각의 파트로 만들어 추적할 수 있습니다.”
> > 
> 
> ---
> 
> ✨ **요약**
> 
> - **Part = 프로젝트의 실질적 단위(Section / Stage)**
> - **Main Counter 1개 + Buddy Counters (선택)** 로 구성
> - 사용자가 이름 지정 및 순서 재배치 가능
> - 도안 기반/사용자 기반 둘 다 지원
> - **작업의 흐름을 시각적·논리적으로 구분하는 최소 단위**

---

### **Part와 Session의 관계**

> Part ↔ Session : 1:1 관계(기본 원칙)
> 
> 
> 하나의 Part에는 **하나의 세션**이 유지되며,
> 
> 해당 세션은 작업 시간의 누적 기록을 담당합니다.
> 
- 사용자가 파트를 변경하면 현재 세션은 **일시정지**되고, 새 파트에서 **새 세션**이 생성됩니다.
- 동일 파트로 돌아와 **이어하기**를 하면, 이전 세션이 **재활성화**됩니다.
- 세션 내부에서는 **일시정지·재개·자정 교차 등 이벤트에 따라 자동으로 세그먼트가 분리되며**,
    
    이 세그먼트는 **앱 내부적으로만 관리되는 단위**로, 사용자는 직접 인식하거나 조작하지 않습니다.
    

즉,

> Part = 작업 구간
> 
> 
> **Session = 그 구간의 누적 작업 시간 기록**
> 

### Part 메모

- 개요

- **메모는 Part 단위로 작성된다.**
- 사용자는 작업 중 떠오른 생각, 다음 작업 계획, 참고사항 등을
    
    Part 화면에서 자유롭게 기록할 수 있다.
    

- 목적

| 목적 | 설명 |
| --- | --- |
| 진행 기록 | “오늘은 40단까지 떴음”, “다음엔 색상 변경부터 시작” 등 |
| 참고 메모 | 사용한 실, 바늘, 밀도 등의 정보 기록 |
| 오류/보정 기록 | “여기서 2코 줄임 잘못함 → 다음 단에서 수정” 등 |

- 구조

```sql
CREATE TABLE part_note (
  id BIGSERIAL PRIMARY KEY,
  part_id BIGINT NOT NULL REFERENCES part(id) ON DELETE CASCADE,
  body TEXT NOT NULL,                  -- 메모 본문
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ,
  pinned BOOLEAN NOT NULL DEFAULT FALSE
);

CREATE INDEX idx_part_note_part ON part_note(part_id);
CREATE INDEX idx_part_note_created ON part_note(part_id, created_at DESC);

```

- 동작 규칙

- 메모는 **Part 화면에서 작성, 수정, 삭제**할 수 있다.
- 기본 정렬: `pinned DESC, created_at DESC`
- 상단 고정된 메모는 항상 목록 상단에 표시된다.
- 메모는 Part와 함께 저장되며, 다른 요소와의 의존 관계는 없다.

- UX 흐름

| 동작 | 결과 |
| --- | --- |
| “메모 추가” | 새 메모가 생성되어 Part에 연결됨 |
| “상단 고정” | 메모가 목록 상단으로 이동 |
| “수정” | 본문 변경, 수정일시 갱신 |
| “삭제” | 사용자 확인 후 메모 제거 |

- 예시 문구

- “메모를 추가했습니다.”
- “상단에 고정했습니다.”
- “메모를 삭제했습니다.”

## Counter System

### - **Part와의 관계**

> Part는 하나의 Main Counter를 기본으로 가진다.
> 
> 
> Main Counter는 해당 파트의 중심 진행을 추적하는 카운터로,
> 
> 각 파트의 작업량(단수·코수·반복 등)을 관리하는 핵심 단위입니다.
> 
- Part 생성 시 자동으로 Main Counter 1개 생성
- Main Counter는 **두 가지 모드** 중 하나로 동작
    - **Row 모드:** 단(행) 진행 추적, 세션과 연동됨
    - **Free 모드:** 자유 카운트, 세션에는 시간만 기록 (추후  개발)
- **Buddy Counter**(보조 카운터)는 Part 단위로 추가 가능하며,
    
    Row 모드일 때만 메인과 **연동(Link)** 가능
    

요약하자면,

> Part = 컨테이너,
> 
> 
> **Main Counter = 그 파트의 중심 카운터**,
> 
> **Buddy Counters = 특정 규칙이나 코 단위를 보조 추적하는 카운터**
> 

### - **Main Counter**

> The primary counter that tracks your main progress within a part.
> 
> 
> 각 파트(예: 몸통, 소매 등)에서 진행 상황을 추적하는 **기본 카운터**입니다.
> 

---

> Each part includes a Main Counter — your primary tracker for rows, stitches, or any other unit you want to count.
> 
> 
> 각 파트에는 하나의 메인 카운터가 포함되어 있으며,
> 
> 행(row), 코(stitch), 또는 원하는 어떤 단위든 자유롭게 세어볼 수 있는 **중심 카운터**입니다.
> 

> You can use it to follow your pattern’s total rows, or simply as a general-purpose counter whenever you need one.
> 
> 
> 도안의 총 단수를 따라가기 위해 사용할 수도 있고,
> 
> 특별한 설정 없이 단순히 세어보고 싶을 때에도 자유롭게 활용할 수 있습니다.
> 

---

### - **Buddy Counter**

> Buddy Counter
> 
> 
> : A secondary counter that supports your Main Counter by tracking detailed progress such as stitch counts, section repeats, or other pattern elements — either independently or in sync with the main progress.
> 
> **Buddy Counter**는 MainCounter(단수)와 함께 작동하는 **보조 카운터 시스템**이다.
> 
> Yarnie의 메인 흐름은 `Project → Part → Counter` 로 구성되며,
> 
> 버디 카운터는 각 파트 내에서 **메인을 보조하거나 독립적으로 작동**한다.
> 

---

1️⃣ **Buddy Counter 유형**

Stitch Counter

**정의**

- 한 시점의 코 수나 묶음 단위를 세는 **즉시형 수동 카운터**
- 메인카운터와 **연동되지 않음 (링크 기능 없음)**

**특징**

- `+ / −` 수동 조작
- `count_by` 설정 가능 (1, 2, 5, 10 등)
- 코 수 점검, 캐스온, 픽업코 세기, 리지 계산 등 순간 세기용

**데이터 모델**

| 필드 | 설명 |
| --- | --- |
| `is_main` | false |
| `buddy_type` | `'stitch'` |
| `count_by` | 사용자가 지정 |
| `current_value` | 현재 값 (독립 증가/감소) |

---

Section Counter

**정의**

메인카운터의 단수 진행을 기반으로 **구간/반복/간격/증감**을 자동 추적하는 보조 카운터.

예: “4행 패턴 × 5회”, “20행마다 색상 변경”, “매 2행 1코 줄임”.

**특징**

- 메인과 **링크(on/off)** 가능
- 링크 해제 시 진행 멈춤(고정 표시)
- 재링크 시 **현재 메인값으로 동기화**
- 계산은 **결정적(clamp) 수식**으로 수행

---

2️⃣ **Section Counter 링크 기능**

| 상태 | 설명 |
| --- | --- |
| **linked** | 메인카운터의 값으로 실시간 계산 (자동 진행) |
| **unlinked** | 진행 멈춤. 메인 변화 무시. 고정 표시 유지 |

**전이 규칙**

| 전이 | 설명 |
| --- | --- |
| **언링크 시** | `link_state='unlinked'`, `frozen_main_at = currentMain` |
| **재링크 시** | `link_state='linked'`, `frozen_main_at=NULL` → 현재 메인 기준으로 즉시 동기화 |

**UX**

- 언링크: “연결 해제됨” 배지 표시
- 재링크: 바로 이어하기 (또는 모달 `[이어하기] / [취소]`)

---

**3️⃣ 메인카운터 값 변경(되돌림·점프) 흐름**

| 링크 상태 | 섹션 카운터 반응 |
| --- | --- |
| linked | clamp 수식으로 즉시 재계산 |
| unlinked | `frozen_main_at` 기준 그대로 유지, 표시값 변화 없음 |

---

**4️⃣ 데이터 모델 (Drift 기준)**

**Counters (공통)**

```dart
Int id;
Int partId;
Bool isMain;
Text? buddyType;         // 'stitch'|'section'
Int? countBy;
Bool? linkedToMainCounter;
Int? currentValue;
```

**SectionCounters**

```dart
Int buddyId;             // FK → counters.id
Text specJson;           // JSON 스펙
Text linkState;          // 'linked' | 'unlinked'
Int? frozenMainAt;       // 언링크 시 고정 기준
Int schemaVer = 1;
```

**SectionRuns**

```dart
Int id;
Int buddyId;
Int ord;
Int startRow;
Int rowsTotal;
Text? label;
Text state;              // 'scheduled'|'active'|'completed'|'skipped'
```

---

**5️⃣ 계산식**

```
X = (link_state == 'linked') ? main : frozen_main_at
progress_i = clamp(X - start_row_i, 0, rows_total_i)
```

- 전체 진행률: `Σ(progress_i) / Σ(rows_total_i)`
- 활성 런: `progress_i < rows_total_i` 중 첫 번째
- 남은 행: `rows_total_active - progress_active`

---

6️⃣ **SectionRun의 역할**

| 항목 | 설명 |
| --- | --- |
| **정의** | 스펙(specJson)을 “행 구간(run)” 단위로 전개한 캐시 |
| **역할** | 계산 단순화, 성능 최적화, UI 즉시 표시 |
| **활용** | 각 런별 진행도 계산, 현재 런/다음 이벤트 탐색, 완료율 표시 |
| **상태(state)** | scheduled / active / completed / skipped |

---

7️⃣ **SectionState 정의**

| 필드 | 설명 |
| --- | --- |
| `link_state` | linked/unlinked 상태 |
| `frozen_main_at` | 언링크 시점 메인값 |
| `schema_ver` | 스펙 구조 버전 |
| `state (run별)` | scheduled / active / completed / skipped |
| `progress` | clamp 기반 진행값 |

---

8️⃣ **Section Counter 세부유형**

**🟩 Range Type (구간 추적형)**

- **정의**: 지정한 시작행부터 일정 길이만큼의 단일 구간 추적
- **예시**: “60행부터 10행 동안 코 줄임”
- **specJson**

```json
{ "type": "range", "start_row": 60, "rows_total": 10, "label": "감아코 구간" }
```

- **runs**
    
    
    | ord | start_row | rows_total | label |
    | --- | --- | --- | --- |
    | 1 | 60 | 10 | 감아코 구간 |

---

**🟦 Repeat Type (패턴 반복형)**

- **정의**: 정해진 단위(`rows_per_repeat`)를 여러 번 반복 추적
- **예시**: “4행 패턴을 5회 반복 (60행부터)”
- **specJson**

```json
{ "type": "repeat", "start_row": 60, "rows_per_repeat": 4, "repeat_count": 5, "label": "차트 A" }
```

- **runs**
    
    
    | ord | start_row | rows_total | label |
    | --- | --- | --- | --- |
    | 1 | 60 | 4 | 차트A#1 |
    | 2 | 64 | 4 | 차트A#2 |
    | 3 | 68 | 4 | 차트A#3 |
    | 4 | 72 | 4 | 차트A#4 |
    | 5 | 76 | 4 | 차트A#5 |

---

**🟨 Interval Type (간격형)**

- **정의**: 일정 간격마다 이벤트 발생
- **예시**: “60행부터 20행마다 색상 변경 (A→B→C 순환)”
- **specJson**

```json
{
  "type": "interval",
  "start_row": 60,
  "interval_rows": 20,
  "action": "color",
  "palette": ["A", "B", "C"]
}
```

- **runs**
    
    
    | ord | start_row | rows_total | label |
    | --- | --- | --- | --- |
    | 1 | 60 | 20 | A |
    | 2 | 80 | 20 | B |
    | 3 | 100 | 20 | C |
    | 4 | 120 | 20 | A |
- **상한 정책**
    
    목표행 있으면 그까지, 없으면 `+300행`까지만 전개 후 필요 시 append.
    

---

**🟥 Shaping Type (증감형)**

- **정의**: 일정 간격마다 코 수가 증감하는 패턴
- **예시**: “60행부터 매 2행마다 1코 줄임 × 8회”
- **specJson**

```json
{
  "type": "shaping",
  "start_row": 60,
  "interval_rows": 2,
  "amount": -1,
  "repeat_count": 8
}
```

- **runs**
    
    
    | ord | start_row | rows_total | label |
    | --- | --- | --- | --- |
    | 1 | 60 | 2 | -1코 |
    | 2 | 62 | 2 | -1코 |
    | … | … | … | … |
    | 8 | 74 | 2 | -1코 |

---

**🟧 Length Type (길이 추적형)**

- **정의**: 게이지 정보를 기반으로 **길이(cm 또는 inch)** 기준으로 목표 지점을 추적하는 유형.
    
    사용자가 입력한 게이지(10cm당 단 수)를 바탕으로, 목표 길이를 **필요 행 수**로 환산해 자동 진행률을 계산한다.
    
    “25cm가 될 때까지 뜨기” 같은 도안 서술을 대신 관리한다.
    
- **예시**: “25cm가 될 때까지 떠라”
    
    → 게이지가 10cm당 26단이라면, 약 65행 정도가 필요함.
    
    → 앱은 이 값을 계산하여 자동으로 목표 진행률을 표시.
    
- **specJson**

```json
{
  "type": "length",
  "start_row": 60,
  "mode": "target",
  "units": "cm",
  "target_length": 25.0,
  "gauge_rows_per_10cm": 26,
  "rounding": "ceil",
  "tolerance_rows": 2,
  "label": "≈25cm 구간"
}
```

- **runs**
    
    
    | ord | start_row | rows_total | label |
    | --- | --- | --- | --- |
    | 1 | 60 | 65 | ≈25cm 구간 |
    
    (계산 예시: 10cm당 26단 → 25cm ÷ (10/26) = 65.0단 → 올림하여 65행)
    
- **계산 흐름**
    - **행 높이(cm)** = `10 / gauge_rows_per_10cm`
    - **목표 행 수** = `target_length / 행높이` → `rounding` 적용
    - 진행도: `progress = clamp(X - start_row, 0, rows_total)`
    - 완료 판정 시 `tolerance_rows`(여유 단수) 고려 가능
    - **X**는 `linked`일 때 `main`, `unlinked`일 때 `frozen_main_at` 사용.
- **특징**
    - 사용자는 게이지(단/10cm)와 목표 길이만 입력하면 됨.
    - 앱이 자동으로 예상 단 수를 계산해 표시.
    - 도안에 자주 등장하는 “N cm까지 뜨기” 패턴을 단수로 자동 관리.
    - 실제 길이 측정은 여전히 사용자가 줄자로 확인하지만,
        
        “언제쯤 재보면 될지”를 예측할 수 있어 불필요한 재측정을 줄임.
        

---

**🧶 Section Counter 유형별 실전 패턴 분류**

| 상위 Type | 대표 상황(자연어 표현) | 예시 문장 | 설명 / 동작 요약 |
| --- | --- | --- | --- |
| 🟩 **Range (구간 추적형)** | “특정 구간 동안 어떤 작업을 반복” | “60행부터 10행 동안 코 줄임” / “20행부터 12행 동안 무늬뜨기” | 시작행과 길이 지정, 그 구간 전체를 하나의 ‘진행 범위’로 추적 |
|  | **코 줄임 구간** | “60행부터 10행 동안 코 줄임” | 10행짜리 감소 작업이 연속될 때 구간 전체를 표시 |
|  | **무늬 구간** | “20행부터 12행 동안 무늬뜨기 A” | 도안 내 특정 패턴 차트(예: 레이스, 케이블 등)를 한 덩어리로 표시 |
|  | **색상 구간** | “30행부터 15행까지 색상 B 사용” | 색상 교체가 한 구간에만 적용될 때 |
| 🟦 **Repeat (패턴 반복형)** | “단위 패턴을 여러 번 반복” | “4행 패턴 × 5회” | `rows_per_repeat`와 `repeat_count`로 반복 단위 추적 |
|  | **무늬 반복** | “8행 무늬 패턴 3회 반복” | 차트/도안 반복 |
|  | **리브 반복** | “2행 리브 패턴 반복” | 단순 리브(고무단)나 기본 패턴 루프 |
| 🟨 **Interval (간격형)** | “매 N행마다 어떤 일이 일어남” | “20행마다 색상 변경” / “8행마다 케이블 교차” | 일정 간격마다 반복 이벤트 발생, 상한선까지 전개 |
|  | **색상 교체** | “20행마다 색상 변경” | 팔레트 순환 가능 |
|  | **케이블 교차** | “8행마다 케이블 트위스트” | 간격별 표시/알림용 |
|  | **무늬 교체** | “16행마다 패턴 변경” | Interval의 일반화 형태 |
| 🟥 **Shaping (증감형)** | “일정 간격마다 코 수를 늘이거나 줄임” | “매 2행마다 1코 줄임 × 8회” | 단위 간격·반복횟수 기반, 증감량(amount)을 추적 |
|  | **줄임 패턴** | “매 2행마다 1코 줄임” | 감소량 누적 표시 |
|  | **늘림 패턴** | “매 2행마다 1코 늘림” | 증가량 누적 표시 |
|  | **혼합형** | “4행마다 2코 늘림, 6행마다 1코 줄임” | 복수 shaping counter로 표현 가능 |
| 🟧 **Length (길이 추적형)** | “길이(cm/in) 기준으로 목표 추적” | “25cm까지 뜨기” | 게이지(단/10cm) 기반으로 길이를 행 수로 환산해 목표 추적 |

---

**🧩 Range vs Shaping 차이 정리**

| 구분 | Range Type | Shaping Type |
| --- | --- | --- |
| **기준** | “특정 구간을 **묶어서** 추적” | “일정 **간격마다** 코 수 변화(증감)” |
| **행 단위** | 전체 범위를 한 덩어리로 추적 | 각 증감 단위를 run으로 분리 |
| **예시** | “60~70행 동안 줄임 구간” | “매 2행마다 1코 줄임 × 8회” |
| **표시 목적** | *‘이 구간 작업 중’*을 표시 | *‘이번 줄임 몇 번째인지’*를 추적 |
| **진행 표현** | 범위 진행률(10행 중 6행 완료) | 반복진행(8회 중 4회 완료) + 누적 증감량 표시 |
| **사용 상황** | 도안에 “~까지”처럼 구간으로 서술된 경우 | 도안에 “매 ~마다”처럼 규칙적 반복이 있는 경우 |

> 🔍 정리하자면
> 
> - **“몇 행부터 몇 행까지”** → Range
> - **“매 몇 행마다”** → Shaping
>     
>     두 문장 중 어떤 표현이 도안에 쓰였는지로 판단하면 됨
>     

---

**💡 요약**

| 구분 | 사용자에게 보여질 이름 예시 |
| --- | --- |
| Range | 코 줄임 구간 / 무늬 구간 / 색상 구간 |
| Repeat | 무늬 반복 / 리브 반복 |
| Interval | 색상 교체 / 케이블 교차 |
| Shaping | 줄임 패턴 / 늘림 패턴 |
| Length | 길이 추적 (cm 기준) |

---

이렇게 하면 UI에선 내부 `type` 대신

- 상위 카테고리(=type 이름)
- 하위 자연어 옵션(=sub_type 이름) 조합으로 노출

예를 들어:

> “버디 카운터 추가 → 섹션 카운터 → 구간 추적형 → 코 줄임 구간”
> 

이렇게 2단 구성으로 노출하면,

초보 사용자도 “아, 이건 코 줄임 구간을 세는 거구나” 하고 바로 이해 가능

**🔢 계산 공식 요약**

```
X = (link_state == 'linked') ? main : frozen_main_at
progress_i = clamp(X - start_row_i, 0, rows_total_i)
total_progress = Σ(progress_i)
ratio = total_progress / Σ(rows_total_i)
active_run = 첫 번째 progress_i < rows_total_i
next_event_in = rows_total_active - progress_active
```

---

**✅ 최종 요약**

| 항목 | 요약 |
| --- | --- |
| **Stitch Counter** | 독립 즉시형, 링크 없음 |
| **Section Counter** | 메인 연동형, linked/unlinked 전환 지원 |
| **Unlink 시** | 진행 멈춤, frozen_main_at 기준 표시 |
| **Relink 시** | 현재 메인값으로 즉시 동기화 |
| **계산식** | clamp(main−start_row, 0, rows_total) |
| **section_runs** | 구간 전개 캐시 |
| **세부유형** | range / repeat / interval / shaping |
| **시작행 비워둘 시** | 저장 시점 메인값으로 자동 확정 |

---

> 핵심 철학
> 
> - StitchCounter → “순간 세기용”
> - SectionCounter → “진행 추적용”
> - 단순한 데이터 구조(spec + run)로 모든 유형을 표현하고,
>     
>     메인값 변화는 clamp 기반 결정적 계산으로 처리한다.
>     

## **Session**

> Session
> 
> 
> : A record of your knitting time — tracking when and how long you worked on a part.
> 
> **세션은 사용자의 뜨개 시간을 기록하는 단위입니다.**
> 
> 사용자가 작업을 시작하면 세션이 생성되고, 일시정지·이어하기의 흐름을 자동으로 관리합니다.
> 
> 세션은 단순한 타이머가 아니라, **“내가 얼마나 꾸준히 뜨개를 해왔는가”를 시각화하는 기록**으로서
> 
> 히트맵, 통계, 작업 로그 등의 기반이 됩니다.
> 
- **세션 시작 시:** 현재 Part와 자동 연결되어 작업 기록을 시작합니다.
- **일시정지 시:** 세션이 일시정지되며, 작업 시간이 누적 저장됩니다.
- **이어하기 시:** 세션이 재시작되어, 이전 누적 시간에 이어 계속 기록합니다.

세션은 앱이 자동으로 관리하며,

사용자는 시작·일시정지·이어하기만으로 자신의 작업 흐름을 간단히 기록할 수 있습니다.

### SessionSegment

> Session Segment
> 
> 
> : Automatically divided intervals within a session.
> 

**세션 세그먼트는 앱 내부적으로 관리되는 시간 구간 단위**입니다.

사용자는 직접 인식하거나 조작하지 않으며,

세션이 일시정지·재시작되거나, 모드 변경·자정 교차 등이 발생할 때마다

자동으로 새로운 세그먼트가 생성됩니다.

각 세그먼트는 세션의 세부 기록으로,

**히트맵과 통계 계산에 사용되는 기본 단위**입니다.

[사용자 동작에 따른 ‘Segment’ Flow](Version%201%20%EA%B8%B0%ED%9A%8D/%EC%82%AC%EC%9A%A9%EC%9E%90%20%EB%8F%99%EC%9E%91%EC%97%90%20%EB%94%B0%EB%A5%B8%20%E2%80%98Segment%E2%80%99%20Flow%2029408fa3261c805e8a2cdf754cca91d4.md)

### **Session, Counter, Part 관계도 (텍스트 버전)**

```mathematica
Project
 ├── Part (N)
 │    ├── MainCounter (1)
 │    │     ├── mode: Row
 │    │     └── BuddyCounters (N)
 │    │            ├── StitchCounter (count-by 가능, 독립 +/– 조작 가능)
 │    │            └── SectionCounter (Row 모드 전용, 메인과 연동)
 │    │
 │    ├── Session (1)      ← Part당 1개 유지
 │    │     ├── part_id
 │    │     ├── started_at / ended_at
 │    │     ├── total_duration
 │    │     ├── status: running / paused / ended
 │    │     └── SessionSegments (N)   ← 앱 내부 관리용 구간
 │    │            ├── started_at / ended_at / duration
 │    │            └── reason (pause / resume / part_change / mode_change / midnight_split)
 │    │
 │    └── PartNotes (N)
 │          ├── body
 │          ├── pinned
 │          ├── created_at / updated_at
 │          └── part_id
 │
 └── ...
```

요약

- **Session**은 **Part**에 속하며,
- **Session Segment**는 세션의 실제 시간 구간(일시정지·재시작 등)
- **Main Counter**는 파트의 중심 카운터이며, 세션의 Row 모드 통계와 직접 연동됨.
- 모든 통계(히트맵, 단 페이스, 누적 시간)는 이 관계를 기반으로 계산됨.

### Session 백그라운드 동작 아이디어

“배터리·정확성·간편성” 균형으로 이렇게 가져가면 깔끔해.

1) 기본 원칙 (권장 디폴트)

- **화면 꺼져도 세션 계속**(저전력 백그라운드 타이머)
    - 안드로이드: **foreground service + 지속 알림**(Pause/End 액션)
    - iOS: **background task**로 타임스탬프 기록(실시간 틱이 아니라 *시작/종료 시각*으로 차이 계산)
- **모드 토글 제공:** `화면 켜짐 유지`(Off 기본) / On 시에만 화면 유지

> 이유: 손은 뜨개에 쓰고, 폰은 주머니에 넣어도 시간은 계속 쌓이게.
> 

2) 앱 이탈/화면 꺼짐 동작 규칙

- **포그라운드 → 백그라운드 전환:** 타이머 **지속**. 알림에 `Pause / End` 버튼 노출
- **화면 꺼짐:** 타이머 **지속**(화면만 off)
- **장기 백그라운드 안전장치(옵션):**
    - `X분 이상` 백그라운드면 **확인 알림**: “아직 뜨개 중인가요?” → `[계속] [일시정지]`
    - 응답 없으면 **자동 일시정지**(예: 2분 후). 복귀 시 “그동안 시간을 추가할래요?” 슬라이더 제공

3) 복귀 시 정산 UX (레퍼런스 앱 패턴 개선)

- 앱 복귀 시 자동 비교: `지금 - 마지막 확정 시각 = Δ`
- **짧은 이탈(예: ≤3분):** 묻지 않고 **그대로 반영**(마찰 최소)
- **긴 이탈(>3분):** 미니 다이얼로그
    - “앱을 떠난 뒤 **10분** 지났습니다. 시간에 반영할까요?”
    - 버튼: `[예, 반영] [아니오] [직접 조정…]`(슬라이더/±1분)

4) 데이터 모델/정확도 포인트

- **세션은 컨테이너, 세그먼트는 구간**: 백그라운드에서 `일시정지/재시작/자정 교차/모드·파트 변경` 시 **세그먼트 자동 분할**(UI에는 노출 안 함).
- **시계 사용:** 실시간 카운트가 아니라 **모노토닉 시간** 기반 Δ 계산
    - Android: `elapsedRealtime()`
    - iOS: `ProcessInfo.systemUptime`
        
        → DST/시간대 변경/수동 시계조정 영향 없음
        
- **크래시/OS kill 대비:** 시작 타임스탬프를 로컬DB에 즉시 저장(저널링). 재실행 시 **Δ 재계산 후 복구**.

5) 설정(사용자 제어)

- `화면 켜짐 유지`: Off 기본
- `백그라운드 자동 일시정지`: On 기본, 임계값(5/10/15/무제한) 선택
- `복귀 시 묻기`: “3분 이상 이탈 시만” 기본

6) 요약 UX 문구

- “**화면이 꺼져도 세션은 계속됩니다.** 상단 알림에서 일시정지할 수 있어요.”
- “**오래 떠나셨네요 (10분)**. 시간에 반영할까요?” `[반영] [미반영] [조정]`

이렇게 가면:

- 배터리 과소모 없이 **끊김 없는 기록**
- 사용자 개입 최소화 + **실수/방치 방지**
- 통계(히트맵/페이스) 정합성 유지 됩니다.